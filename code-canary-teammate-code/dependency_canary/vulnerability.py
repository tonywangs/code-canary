"""
Vulnerability enrichment module for querying security databases.
"""

import asyncio
import httpx
import os
from datetime import datetime
from typing import List, Dict, Any, Optional
from loguru import logger

from .models import (
    SBOM, ScanResult, Vulnerability, PackageRisk, RiskFactor,
    SeverityLevel, RiskLevel, Package
)

class VulnerabilityEnricher:
    """Enriches SBOM with vulnerability data from multiple sources."""
    
    def __init__(self):
        """Initialize vulnerability enricher."""
        self.osv_api_url = "https://api.osv.dev/v1"
        self.ghsa_api_url = "https://api.github.com/advisories"
        self.nvd_api_url = "https://services.nvd.nist.gov/rest/json/cves/2.0"
        self.nvd_api_key = os.getenv("NVD_API_KEY")
        
        # Rate limiting
        self.max_concurrent_requests = 10
        self.request_delay = 0.1  # seconds between requests
    
    async def enrich_sbom(self, sbom: SBOM) -> ScanResult:
        """Enrich SBOM with vulnerability data.
        
        Args:
            sbom: SBOM to enrich
            
        Returns:
            Scan result with vulnerability data
        """
        logger.info(f"Enriching SBOM with {sbom.total_packages} packages")
        
        scan_result = ScanResult(sbom=sbom)
        
        # Create semaphore for rate limiting
        semaphore = asyncio.Semaphore(self.max_concurrent_requests)
        
        # Process packages in batches
        async with httpx.AsyncClient(timeout=30.0) as client:
            tasks = []
            for package in sbom.packages:
                task = self._enrich_package(client, semaphore, package)
                tasks.append(task)
            
            # Execute enrichment tasks
            results = await asyncio.gather(*tasks, return_exceptions=True)
            
            # Process results
            for i, result in enumerate(results):
                if isinstance(result, Exception):
                    logger.error(f"Failed to enrich package {sbom.packages[i].name}: {result}")
                    continue
                
                if result:  # PackageRisk object
                    scan_result.add_package_risk(result)
        
        logger.info(f"Enrichment complete: {scan_result.total_vulnerabilities} vulnerabilities found")
        return scan_result
    
    async def _enrich_package(self, client: httpx.AsyncClient, semaphore: asyncio.Semaphore, 
                            package: Package) -> Optional[PackageRisk]:
        """Enrich a single package with vulnerability data.
        
        Args:
            client: HTTP client
            semaphore: Rate limiting semaphore
            package: Package to enrich
            
        Returns:
            Package risk assessment or None if no vulnerabilities found
        """
        async with semaphore:
            try:
                # Add delay for rate limiting
                await asyncio.sleep(self.request_delay)
                
                vulnerabilities = []
                risk_factors = []
                
                # Query OSV, GHSA, and NVD in parallel
                tasks = [
                    self._query_osv(client, package),
                    self._query_ghsa(client, package),
                    self._query_nvd(client, package),
                ]
                results = await asyncio.gather(*tasks, return_exceptions=True)
                for res in results:
                    if isinstance(res, Exception):
                        logger.debug(f"One vuln source failed for {package.name}: {res}")
                        continue
                    vulnerabilities.extend(res or [])
                
                # Add risk heuristics
                risk_factors.extend(await self._analyze_risk_factors(client, package))
                
                # Calculate overall risk
                if vulnerabilities or risk_factors:
                    overall_risk, risk_score = self._calculate_risk_score(vulnerabilities, risk_factors)
                    
                    return PackageRisk(
                        package_purl=package.purl,
                        overall_risk=overall_risk,
                        risk_score=risk_score,
                        vulnerabilities=vulnerabilities,
                        risk_factors=risk_factors
                    )
                
                return None
                
            except Exception as e:
                logger.error(f"Failed to enrich package {package.name}: {e}")
                return None
    
    async def _query_osv(self, client: httpx.AsyncClient, package: Package) -> List[Vulnerability]:
        """Query OSV.dev for vulnerabilities.
        
        Args:
            client: HTTP client
            package: Package to query
            
        Returns:
            List of vulnerabilities
        """
        try:
            # Construct query payload
            query_data = {
                "package": {
                    "name": package.name,
                    "ecosystem": self._get_osv_ecosystem(package.package_manager)
                },
                "version": package.version
            }
            
            response = await client.post(
                f"{self.osv_api_url}/query",
                json=query_data
            )
            
            if response.status_code == 200:
                data = response.json()
                vulnerabilities = []
                
                for vuln_data in data.get("vulns", []):
                    vulnerability = self._parse_osv_vulnerability(vuln_data)
                    if vulnerability:
                        vulnerabilities.append(vulnerability)
                
                return vulnerabilities
            
        except Exception as e:
            logger.debug(f"OSV query failed for {package.name}: {e}")
        
        return []
    
    async def _query_ghsa(self, client: httpx.AsyncClient, package: Package) -> List[Vulnerability]:
        """Query GitHub Security Advisories.
        
        Args:
            client: HTTP client
            package: Package to query
            
        Returns:
            List of vulnerabilities
        """
        try:
            # GitHub API requires different ecosystem names
            ecosystem = self._get_ghsa_ecosystem(package.package_manager)
            if not ecosystem:
                return []
            
            params = {
                "ecosystem": ecosystem,
                "affects": package.name,
                "per_page": 100
            }
            
            response = await client.get(
                self.ghsa_api_url,
                params=params
            )
            
            if response.status_code == 200:
                advisories = response.json()
                vulnerabilities = []
                
                for advisory in advisories:
                    vulnerability = self._parse_ghsa_advisory(advisory)
                    if vulnerability:
                        vulnerabilities.append(vulnerability)
                
                return vulnerabilities
            
        except Exception as e:
            logger.debug(f"GHSA query failed for {package.name}: {e}")
        
        return []
    
    async def _query_nvd(self, client: httpx.AsyncClient, package: Package) -> List[Vulnerability]:
        """Query NVD CVE 2.0 API for vulnerabilities using keywordSearch.
        """
        try:
            params = {
                "keywordSearch": f"{package.name} {package.version}",
                "resultsPerPage": 200,
            }
            if self.nvd_api_key:
                params["apiKey"] = self.nvd_api_key

            resp = await client.get(self.nvd_api_url, params=params)
            if resp.status_code == 200:
                data = resp.json() or {}
                vulns: List[Vulnerability] = []
                for item in data.get("vulnerabilities", []):
                    cve = item.get("cve")
                    if not cve:
                        continue
                    v = self._parse_nvd_cve(cve)
                    if v:
                        vulns.append(v)
                return vulns
        except Exception as e:
            logger.debug(f"NVD query failed for {package.name}: {e}")
        return []
    
    def _parse_nvd_cve(self, cve: Dict[str, Any]) -> Optional[Vulnerability]:
        """Parse a single NVD CVE item into a Vulnerability."""
        try:
            cve_id = cve.get("id", "")
            descriptions = cve.get("descriptions", [])
            desc_en = next((d.get("value") for d in descriptions if d.get("lang") == "en"), "")

            # CVSS metrics
            cvss_score: Optional[float] = None
            cvss_vector: Optional[str] = None
            severity = SeverityLevel.UNKNOWN
            metrics = cve.get("metrics", {})
            for key in ("cvssMetricV31", "cvssMetricV30", "cvssMetricV2"):
                arr = metrics.get(key)
                if isinstance(arr, list) and arr:
                    data = arr[0].get("cvssData", {})
                    score = data.get("baseScore")
                    vector = data.get("vectorString")
                    if score is not None:
                        cvss_score = float(score)
                        severity = self._cvss_to_severity(cvss_score)
                    if vector:
                        cvss_vector = vector
                    break

            references = [r.get("url", "") for r in cve.get("references", []) if r.get("url")]

            return Vulnerability(
                id=cve_id,
                source="nvd",
                title=cve.get("sourceIdentifier", cve_id),
                description=desc_en,
                severity=severity,
                cvss_score=cvss_score,
                cvss_vector=cvss_vector,
                published_date=self._parse_date(cve.get("published")),
                modified_date=self._parse_date(cve.get("lastModified")),
                affected_packages=[],
                references=references,
            )
        except Exception as e:
            logger.error(f"Failed to parse NVD CVE: {e}")
            return None
    
    async def _analyze_risk_factors(self, client: httpx.AsyncClient, package: Package) -> List[RiskFactor]:
        """Analyze risk factors for a package.
        
        Args:
            client: HTTP client
            package: Package to analyze
            
        Returns:
            List of risk factors
        """
        risk_factors = []
        
        # Typosquatting detection
        typosquat_risk = await self._check_typosquatting(package)
        if typosquat_risk:
            risk_factors.append(typosquat_risk)
        
        # Package age and maintenance checks would go here
        # For now, return empty list
        
        return risk_factors
    
    async def _check_typosquatting(self, package: Package) -> Optional[RiskFactor]:
        """Check for potential typosquatting.
        
        Args:
            package: Package to check
            
        Returns:
            Risk factor if typosquatting detected
        """
        # This is a simplified typosquatting check
        # In a real implementation, you'd compare against popular package names
        
        suspicious_patterns = [
            "reqeusts",  # requests
            "urlib3",    # urllib3
            "beatifulsoup",  # beautifulsoup
            "pillow",    # PIL/Pillow confusion
        ]
        
        if package.name.lower() in suspicious_patterns:
            return RiskFactor(
                type="typosquat",
                severity=RiskLevel.HIGH,
                description=f"Package name '{package.name}' may be a typosquatting attempt",
                evidence={"package_name": package.name},
                confidence=0.8
            )
        
        return None
    
    def _parse_osv_vulnerability(self, vuln_data: Dict[str, Any]) -> Optional[Vulnerability]:
        """Parse OSV vulnerability data.
        
        Args:
            vuln_data: Raw vulnerability data from OSV
            
        Returns:
            Parsed vulnerability or None
        """
        try:
            # Parse severity
            severity = SeverityLevel.UNKNOWN
            cvss_score = None
            
            if "severity" in vuln_data:
                for sev in vuln_data["severity"]:
                    if sev.get("type") == "CVSS_V3":
                        score_value = sev.get("score", 0)
                        # Handle both numeric scores and vector strings
                        if isinstance(score_value, (int, float)):
                            cvss_score = float(score_value)
                        elif isinstance(score_value, str):
                            # Check if it's a direct number as string
                            if score_value.replace('.', '', 1).isdigit():
                                cvss_score = float(score_value)
                            # Handle CVSS vector strings
                            elif score_value.startswith("CVSS:"):
                                # Extract base score from vector or estimate from severity indicators
                                logger.debug(f"Received CVSS vector instead of score: {score_value}")
                                # Use severity level from the vector's impact metrics as a fallback
                                if "/C:H/" in score_value and "/I:H/" in score_value and "/A:H/" in score_value:
                                    severity = SeverityLevel.CRITICAL
                                    cvss_score = 9.0  # Estimate
                                elif "/C:H/" in score_value or "/I:H/" in score_value or "/A:H/" in score_value:
                                    severity = SeverityLevel.HIGH
                                    cvss_score = 7.0  # Estimate
                                elif "/C:L/" in score_value or "/I:L/" in score_value or "/A:L/" in score_value:
                                    severity = SeverityLevel.MEDIUM
                                    cvss_score = 5.0  # Estimate
                                elif "/C:N/" in score_value and "/I:N/" in score_value and "/A:N/" in score_value:
                                    severity = SeverityLevel.LOW
                                    cvss_score = 3.0  # Estimate
                        
                        # Only set severity if we don't already have it from the vector string
                        if cvss_score is not None and severity == SeverityLevel.UNKNOWN:
                            severity = self._cvss_to_severity(cvss_score)
                        break
            
            # Parse affected packages
            affected_packages = []
            for affected in vuln_data.get("affected", []):
                if "package" in affected:
                    pkg_name = affected["package"].get("name")
                    ecosystem = affected["package"].get("ecosystem")
                    if pkg_name and ecosystem:
                        affected_packages.append(f"pkg:{ecosystem.lower()}/{pkg_name}")
            
            return Vulnerability(
                id=vuln_data.get("id", ""),
                source="osv",
                title=vuln_data.get("summary", ""),
                description=vuln_data.get("details", ""),
                severity=severity,
                cvss_score=cvss_score,
                published_date=self._parse_date(vuln_data.get("published")),
                modified_date=self._parse_date(vuln_data.get("modified")),
                affected_packages=affected_packages,
                references=[ref.get("url", "") for ref in vuln_data.get("references", [])]
            )
            
        except Exception as e:
            logger.error(f"Failed to parse OSV vulnerability: {e}")
            return None
    
    def _parse_ghsa_advisory(self, advisory: Dict[str, Any]) -> Optional[Vulnerability]:
        """Parse GitHub Security Advisory.
        
        Args:
            advisory: Raw advisory data from GHSA
            
        Returns:
            Parsed vulnerability or None
        """
        try:
            # Parse severity
            severity_str = advisory.get("severity", "unknown").lower()
            severity = {
                "critical": SeverityLevel.CRITICAL,
                "high": SeverityLevel.HIGH,
                "medium": SeverityLevel.MEDIUM,
                "low": SeverityLevel.LOW
            }.get(severity_str, SeverityLevel.UNKNOWN)
            
            # Parse CVSS score
            cvss_score = None
            if "cvss" in advisory and "score" in advisory["cvss"]:
                cvss_score = float(advisory["cvss"]["score"])
            
            return Vulnerability(
                id=advisory.get("ghsa_id", ""),
                source="ghsa",
                title=advisory.get("summary", ""),
                description=advisory.get("description", ""),
                severity=severity,
                cvss_score=cvss_score,
                published_date=self._parse_date(advisory.get("published_at")),
                modified_date=self._parse_date(advisory.get("updated_at")),
                references=[advisory.get("html_url", "")]
            )
            
        except Exception as e:
            logger.error(f"Failed to parse GHSA advisory: {e}")
            return None
    
    def _calculate_risk_score(self, vulnerabilities: List[Vulnerability], 
                            risk_factors: List[RiskFactor]) -> tuple[RiskLevel, float]:
        """Calculate overall risk score for a package.
        
        Args:
            vulnerabilities: List of vulnerabilities
            risk_factors: List of risk factors
            
        Returns:
            Tuple of (risk_level, risk_score)
        """
        score = 0.0
        
        # Score vulnerabilities
        for vuln in vulnerabilities:
            if vuln.severity == SeverityLevel.CRITICAL:
                score += 4.0
            elif vuln.severity == SeverityLevel.HIGH:
                score += 3.0
            elif vuln.severity == SeverityLevel.MEDIUM:
                score += 2.0
            elif vuln.severity == SeverityLevel.LOW:
                score += 1.0
        
        # Score risk factors
        for factor in risk_factors:
            if factor.severity == RiskLevel.CRITICAL:
                score += 3.0 * factor.confidence
            elif factor.severity == RiskLevel.HIGH:
                score += 2.0 * factor.confidence
            elif factor.severity == RiskLevel.MEDIUM:
                score += 1.0 * factor.confidence
        
        # Determine risk level
        if score >= 8.0:
            risk_level = RiskLevel.CRITICAL
        elif score >= 5.0:
            risk_level = RiskLevel.HIGH
        elif score >= 2.0:
            risk_level = RiskLevel.MEDIUM
        elif score > 0:
            risk_level = RiskLevel.LOW
        else:
            risk_level = RiskLevel.NEGLIGIBLE
        
        return risk_level, min(score, 10.0)
    
    def _get_osv_ecosystem(self, package_manager: str) -> str:
        """Get OSV ecosystem name for package manager.
        
        Args:
            package_manager: Package manager name
            
        Returns:
            OSV ecosystem name
        """
        mapping = {
            "npm": "npm",
            "yarn": "npm",
            "pnpm": "npm",
            "pip": "PyPI",
            "poetry": "PyPI",
            "pipenv": "PyPI",
            "conda": "PyPI",
            "maven": "Maven",
            "gradle": "Maven",
            "go_modules": "Go",
            "cargo": "crates.io",
            "bundler": "RubyGems"
        }
        return mapping.get(package_manager, package_manager)
    
    def _get_ghsa_ecosystem(self, package_manager: str) -> Optional[str]:
        """Get GitHub ecosystem name for package manager.
        
        Args:
            package_manager: Package manager name
            
        Returns:
            GitHub ecosystem name or None
        """
        mapping = {
            "npm": "npm",
            "yarn": "npm", 
            "pnpm": "npm",
            "pip": "pip",
            "poetry": "pip",
            "pipenv": "pip",
            "maven": "maven",
            "gradle": "maven",
            "cargo": "cargo",
            "bundler": "rubygems"
        }
        return mapping.get(package_manager)
    
    def _cvss_to_severity(self, cvss_score: float) -> SeverityLevel:
        """Convert CVSS score to severity level.
        
        Args:
            cvss_score: CVSS score (0-10)
            
        Returns:
            Severity level
        """
        if cvss_score >= 9.0:
            return SeverityLevel.CRITICAL
        elif cvss_score >= 7.0:
            return SeverityLevel.HIGH
        elif cvss_score >= 4.0:
            return SeverityLevel.MEDIUM
        elif cvss_score > 0.0:
            return SeverityLevel.LOW
        else:
            return SeverityLevel.INFO
    
    def _parse_date(self, date_str: Optional[str]) -> Optional[datetime]:
        """Parse date string to datetime.
        
        Args:
            date_str: Date string
            
        Returns:
            Parsed datetime or None
        """
        if not date_str:
            return None
        
        try:
            # Handle ISO format
            if "T" in date_str:
                return datetime.fromisoformat(date_str.replace("Z", "+00:00"))
            else:
                return datetime.fromisoformat(date_str)
        except Exception:
            return None
