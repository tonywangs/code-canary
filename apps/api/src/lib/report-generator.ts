import { EnrichedSBOM, AgentAnswer } from '@dependency-canary/shared';

export class ReportGenerator {
  generateMarkdown(sbom: EnrichedSBOM, agentAnswers?: AgentAnswer[]): string {
    const { summary, metadata, packages } = sbom;
    const generatedDate = new Date(sbom.generatedAt).toLocaleDateString();

    let markdown = `# Dependency Security Report

**Project ID:** ${sbom.projectId}  
**Generated:** ${generatedDate}  
**Languages:** ${metadata.languages.join(', ')}  
**Services:** ${metadata.services.join(', ')}  

## Executive Summary

This report provides a comprehensive analysis of your project's dependency graph, identifying security vulnerabilities and supply chain risks.

### Key Metrics

| Metric | Count |
|--------|-------|
| Total Packages | ${summary.counts.packages} |
| Direct Dependencies | ${summary.counts.direct} |
| Transitive Dependencies | ${summary.counts.transitive} |
| **Total Vulnerabilities** | **${summary.counts.vulns}** |
| Critical Vulnerabilities | ${summary.counts.critical} |
| High Severity | ${summary.counts.high} |
| Medium Severity | ${summary.counts.medium || 0} |
| Low Severity | ${summary.counts.low || 0} |

## Risk Assessment

### Critical Findings

${summary.counts.critical > 0 
  ? `⚠️ **${summary.counts.critical} critical vulnerabilities** require immediate attention.`
  : '✅ No critical vulnerabilities found.'
}

${summary.counts.high > 0 
  ? `⚠️ **${summary.counts.high} high-severity vulnerabilities** should be addressed promptly.`
  : '✅ No high-severity vulnerabilities found.'
}

### Top Risk Packages

${summary.topRisks.length > 0 
  ? summary.topRisks.map((risk, index) => 
    `${index + 1}. **${risk.package}@${risk.version}** (Risk Score: ${Math.round(risk.score * 100)}%)
   - ${risk.reason}`
  ).join('\n')
  : 'No significant risk packages identified.'
}

## Detailed Vulnerability Analysis

${this.generateVulnerabilitySection(packages)}

## Package Inventory

### Direct Dependencies

${packages.filter(pkg => pkg.direct).map(pkg => 
  `- **${pkg.name}@${pkg.version}** (${pkg.eco})
  - License: ${pkg.license || 'Unknown'}
  - Services: ${pkg.serviceRefs?.join(', ') || 'None'}
  - Vulnerabilities: ${pkg.vulns?.length || 0}
  ${pkg.vulns?.length ? `- Highest Severity: ${this.getHighestSeverity(pkg)}` : ''}`
).join('\n')}

### Risk Factors

${this.generateRiskFactorsSection(packages)}

${agentAnswers?.length ? this.generateAgentInsights(agentAnswers) : ''}

## Recommendations

1. **Immediate Actions:**
   ${summary.counts.critical > 0 
     ? '- Address all critical vulnerabilities immediately'
     : '- Continue monitoring for new vulnerabilities'
   }
   ${summary.counts.high > 0 
     ? '- Plan updates for high-severity vulnerabilities'
     : ''
   }

2. **Short-term:**
   - Review and update dependency management policies
   - Implement automated vulnerability scanning
   - Consider using dependency pinning for critical packages

3. **Long-term:**
   - Regularly audit dependency licenses
   - Monitor for abandoned packages and plan replacements
   - Implement supply chain security best practices

---

*Report generated by Dependency Canary - AI-powered security analysis*
`;

    return markdown;
  }

  private generateVulnerabilitySection(packages: any[]): string {
    const vulnPackages = packages.filter(pkg => pkg.vulns?.length > 0);
    
    if (vulnPackages.length === 0) {
      return 'No vulnerabilities found in the analyzed packages.';
    }

    return vulnPackages.map(pkg => {
      const criticalVulns = pkg.vulns.filter((v: any) => v.severity === 'CRITICAL');
      const highVulns = pkg.vulns.filter((v: any) => v.severity === 'HIGH');
      
      return `### ${pkg.name}@${pkg.version}

**Ecosystem:** ${pkg.eco}  
**Type:** ${pkg.direct ? 'Direct' : 'Transitive'} Dependency  
**Services:** ${pkg.serviceRefs?.join(', ') || 'None'}  
**Total Vulnerabilities:** ${pkg.vulns.length}

${pkg.vulns.map((vuln: any) => `#### ${vuln.id} (${vuln.severity})
- **CVSS Score:** ${vuln.cvss}
- **Published:** ${vuln.published}
- **Summary:** ${vuln.summary}
- **Affected Ranges:** ${vuln.affectedRanges.join(', ')}
${vuln.exploits?.length ? `- **Exploits Available:** ${vuln.exploits.length}` : ''}
`).join('\n')}
`;
    }).join('\n');
  }

  private generateRiskFactorsSection(packages: any[]): string {
    const riskPackages = packages.filter(pkg => 
      pkg.risk?.abandoned || 
      pkg.risk?.newlyCreated || 
      (pkg.risk?.typoSuspicion && pkg.risk.typoSuspicion > 0.5)
    );

    if (riskPackages.length === 0) {
      return 'No significant risk factors identified in dependencies.';
    }

    return riskPackages.map(pkg => {
      const risks = [];
      if (pkg.risk.abandoned) risks.push('Abandoned package');
      if (pkg.risk.newlyCreated) risks.push('Newly created package');
      if (pkg.risk.typoSuspicion > 0.5) risks.push('Potential typosquatting risk');

      return `- **${pkg.name}@${pkg.version}**: ${risks.join(', ')}`;
    }).join('\n');
  }

  private generateAgentInsights(answers: AgentAnswer[]): string {
    return `
## AI Agent Insights

${answers.map((answer, index) => `
### Q: ${answer.question}

${answer.answerMarkdown}

${answer.remediationPlan.length > 0 ? `
#### Recommended Actions:
${answer.remediationPlan.map((step, stepIndex) => `
${stepIndex + 1}. **${step.title}** (${step.impact} Impact, ${step.estimatedBreakage} Breakage Risk)
   ${step.actions.map(action => `   - ${action}`).join('\n')}
   - Affects: ${step.affectedPackages.join(', ')}
`).join('\n')}
` : ''}
`).join('\n')}
`;
  }

  private getHighestSeverity(pkg: any): string {
    if (!pkg.vulns?.length) return 'NONE';
    
    const severityOrder = ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW'];
    
    for (const severity of severityOrder) {
      if (pkg.vulns.some((v: any) => v.severity === severity)) {
        return severity;
      }
    }
    
    return 'NONE';
  }
}